#include "orm/databasemanager.hpp"

#include <stdexcept>

#include "orm/concerns/hasconnectionresolver.hpp"
#include "orm/databaseconnection.hpp"

#ifdef TINYORM_COMMON_NAMESPACE
namespace TINYORM_COMMON_NAMESPACE
{
#endif
namespace Orm
{

const char *DatabaseManager::defaultConnectionName = const_cast<char *>("tinyorm_default");

// TODO future add support for ::read and ::write db connections silverx
// TODO implement RepositoryFactory silverqx
DatabaseManager::DatabaseManager(const QString &defaultConnection)
{
    m_config.defaultConnection = defaultConnection;

    // Set up the DatabaseManager as a connection resolver
    Concerns::HasConnectionResolver::setConnectionResolver(this);

    // TODO now, prevent more instances??, or eg add allowMoreInstances data member to override this behavior (or allowMoreInstances compile directive?, in that case would be possible to use #ifdef for ::instance() static method ü§î) silverqx
    //    m_instance = this;
}

/* This is needed because of the std::unique_ptr is used in the m_connections
   data member üò≤, and when this dtor is not defined in the cpp, it will be
   generated by the compiler as inline dtor, what cause a compile error. */
DatabaseManager::~DatabaseManager() = default;

//DatabaseManager *DatabaseManager::instance()
//{
//    // TODO now finish silverqx
//    if (!m_instance)
//        throw std::runtime_error("DatabaseManager xx");

//    return m_instance;
//}

DatabaseConnection &DatabaseManager::connection(const QString &name)
{
    const auto &connectionName = parseConnectionName(name);

    /* If we haven't created this connection, we'll create it based on the provided
       config. Once we've created the connections we will configure it. */
    m_connections.try_emplace(connectionName,
                              configure(makeConnection(connectionName)));

    return *m_connections[connectionName];
}

DatabaseManager &
DatabaseManager::addConnection(const QVariantHash &config, const QString &name)
{
    m_config.connections.insert(name, config);

    return *this;
}

const QStringList DatabaseManager::supportedDrivers() const
{
    // TODO future add method to not only supported drivers, but also check if driver is available/loadable by qsqldatabase silverqx
    // aaaaaaaaaaaaaachjo ü§îüòÅ
    return {"mysql"};
    //    return {"mysql", "pgsql", "sqlite", "sqlsrv"};
}

const QString &
DatabaseManager::getDefaultConnection() const
{
    return m_config.defaultConnection;
}

void DatabaseManager::setDefaultConnection(const QString &defaultConnection)
{
    m_config.defaultConnection = defaultConnection;
}

QSharedPointer<QueryBuilder>
DatabaseManager::table(const QString &table, const QString &as, const QString &name)
{
    return connection(name).table(table, as);
}

const QString &
DatabaseManager::parseConnectionName(const QString &name) const
{
    return name.isEmpty() ? getDefaultConnection() : name;
}

std::unique_ptr<DatabaseConnection>
DatabaseManager::makeConnection(const QString &name)
{
    auto &config = configuration(name);

    // TODO future add support for extensions silverqx

    return m_factory.make(config, name);
}

QVariantHash &
DatabaseManager::configuration(QString name)
{
    if (name.isEmpty())
        name = getDefaultConnection();

    /* Get the database connection configuration by the given name.
       If the configuration doesn't exist, we'll throw an exception and bail. */
    if (!m_config.connections.contains(name))
        throw std::invalid_argument(
                "Database connection '" + name.toStdString() + "' not configured.");

    return m_config.connections[name];

    // TODO add ConfigurationUrlParser silverqx
//    return (new ConfigurationUrlParser)
//                ->parseConfiguration($config);
}

std::unique_ptr<DatabaseConnection>
DatabaseManager::configure(std::unique_ptr<DatabaseConnection> connection) const
{
    // TODO next add reconnector silverqx
    return connection;
}

} // namespace Orm
#ifdef TINYORM_COMMON_NAMESPACE
} // namespace TINYORM_COMMON_NAMESPACE
#endif
