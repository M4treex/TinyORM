Todos to check in TinyOrm:
--------------------------

 - QueryBuilder::insertGetId() allows insert with empty attributes, also Model::performInsert() 
   when incrementing == true, but all other insert methods don't, it's big inconsistency, unify it


Documentation TinyOrm Todos:
----------------------------

 - how to refer NULL in docs, for now I leave it NULL


TODOs which look bad in code:
-----------------------------

 - future add onDelete (and similar) callback feature

/*! Delete records from the database. */
void deleteModel()
{
    // TODO future add onDelete (and similar) callback feature silverqx
//    if (isset($this->onDelete)) {
//        return call_user_func($this->onDelete, $this);
//    }

    return toBase().deleteRow();
}


Todo categories:
----------------

Common:

 - api different      : different api than Laravel's Eloquent
 - check              : something to find out ðŸ¤”
 - docs               : document code or update markdown documentation
 - desirable          : feature which is extremely wanted
 - dilemma            : some sort of a fuckup
 - duplicate          : duplicate code
 - future             : task which has lower priority, because still much to do
 - mistake            : bad decision during prototyping ðŸ˜­
 - move               : c++ move semantics
 - mystery            : don't know why that stuff is happening, find out what's up
 - now                : do it before commit
 - next               : next thing in the row to do after commit
 - overflow           : add check code, eg when size_t to int coversion
 - perf               : performance
 - production         : check before deploy to production
 - reliability        : make things more robust and reliable
 - security           : self explaining
 - test               : tasks in auto tests
 - types              : juggling with c++ types

Features related/to implement:

 - default attributes : Default Attribute Values
 - guarded            : related to the mass assignable feature
 - logging            : logging related
 - multidriver        : task related to adding support for another drivers PostgreSQL, SQLite and SQL Server
 - pivot              : pivot table in the many-to-many relationship
 - postgres           : specific to PostgreSQL server
 - primarykey dilema  : different types for primary keys
 - relations          : relations related ðŸ¤“
 - scopes             : query scopes


constructor copy/move snippet:
------------------------------

Torrent(const Torrent &torrent)
    : BaseModel(torrent)
{
    qDebug() << "Torrent copy ctor";
}
Torrent &operator=(const Torrent &torrent)
{
    BaseModel::operator=(torrent);
    qDebug() << "Torrent copy assign";
    return *this;
}
Torrent(Torrent &&torrent)
    : BaseModel(std::move(torrent))
{
    qDebug() << "Torrent move ctor";
}
Torrent &operator=(Torrent &&torrent)
{
    BaseModel::operator=(std::move(torrent));
    qDebug() << "Torrent move assign";
    return *this;
}


conversions:
------------

Makes possible to assign QVector<AttributeItem> to the Model, 
or implicitly converts a QVector<AttributeItem> to Model:

BaseModel(const QVector<AttributeItem> &attributes);
BaseModel(QVector<AttributeItem> &&attributes);

--
Allows initialize the Model with QVector<AttributeItem>:

BaseModel(std::initializer_list<AttributeItem> attributes)
    : BaseModel(QVector<AttributeItem> {attributes.begin(), attributes.end()})
{}

--
Makes possible to assign the Model to the QVector<AttributeItem>, 
or converts the Model to the QVector<AttributeItem>:

operator QVector<AttributeItem>() const;


Ranges transform:
-----------------

const auto relationToWithItem = [](const auto &relation) -> WithItem
{
    return WithItem {relation};
};

builder->with(relations | ranges::views::transform(relationToWithItem)
                        | ranges::to<QVector<WithItem>>());


DatabaseConnection config:
--------------------------

QHash<QString, QVariant> config {
//    {"driver",         "mysql"},
//    {"url",            qEnvironmentVariable("DATABASE_URL")},
    {"host",           qEnvironmentVariable("DB_HOST", "127.0.0.1")},
    {"port",           qEnvironmentVariable("DB_PORT", "3306")},
    {"database",       qEnvironmentVariable("DB_DATABASE", "")},
    {"username",       qEnvironmentVariable("DB_USERNAME", "root")},
    {"password",       qEnvironmentVariable("DB_PASSWORD", "")},
//    {"unix_socket",    qEnvironmentVariable("DB_SOCKET", "")},
    {"charset",        qEnvironmentVariable("DB_CHARSET", "utf8mb4")},
    {"collation",      qEnvironmentVariable("DB_COLLATION", "utf8mb4_unicode_ci")},
//    {"prefix",         ""},
//    {"prefix_indexes", true},
    {"strict",         true},
//    {"engine",         {}},
    {"options",        ""},
};


DatabaseConnection debug code:
------------------------------

{
    auto [ok, query] = select("select @@session.time_zone, @@global.time_zone");
    while(query.next()) {
        qDebug().nospace() << query.value(0).toString() << "\n"
                 << query.value(1).toString();
    }
}

{
    auto [ok, query] = select("select @@session.character_set_client, @@session.character_set_connection, "
            "@@session.character_set_results, @@session.collation_connection");
            while(query.next()) {
        qDebug().nospace() << query.value(0).toString() << "\n"
                 << query.value(1).toString() << "\n"
                 << query.value(2).toString() << "\n"
                 << query.value(3).toString();
    }
}

{
    auto [ok, query] = select("select @@global.character_set_client, @@global.character_set_connection, "
            "@@global.character_set_results, @@global.collation_connection");
    while(query.next()) {
        qDebug().nospace() << query.value(0).toString() << "\n"
                 << query.value(1).toString() << "\n"
                 << query.value(2).toString() << "\n"
                 << query.value(3).toString();
    }
}

{
    auto [ok, query] = select("select @@global.sql_mode, @@session.sql_mode");
            while(query.next()) {
        qDebug().nospace() << query.value(0).toString() << "\n"
         << query.value(1).toString();
    }
}


tmp notes:
----------

message(-------)
message(XXX config.pri)
message(PWD: $$PWD)
message(OUT_PWD: $$OUT_PWD)
message(_PRO_FILE_PWD_: $$_PRO_FILE_PWD_)
message(INCLUDEPATH: $$INCLUDEPATH)
message(-------)


TinyORM: Relations - Many to Many:
----------------------------------

<a name="many-to-many"></a>
## Many To Many Relationships

Many-to-many relations are slightly more complicated than `hasOne` and `hasMany` relationships. An example of a many-to-many relationship is a user that has many roles and those roles are also shared by other users in the application. For example, a user may be assigned the role of "Author" and "Editor"; however, those roles may also be assigned to other users as well. So, a user has many roles and a role has many users.

<a name="many-to-many-table-structure"></a>
#### Table Structure

To define this relationship, three database tables are needed: `users`, `roles`, and `role_user`. The `role_user` table is derived from the alphabetical order of the related model names and contains `user_id` and `role_id` columns. This table is used as an intermediate table linking the users and roles.

Remember, since a role can belong to many users, we cannot simply place a `user_id` column on the `roles` table. This would mean that a role could only belong to a single user. In order to provide support for roles being assigned to multiple users, the `role_user` table is needed. We can summarize the relationship's table structure like so:

    users
        id - integer
        name - string

    roles
        id - integer
        name - string

    role_user
        user_id - integer
        role_id - integer

<a name="many-to-many-model-structure"></a>
#### Model Structure

Many-to-many relationships are defined by writing a method that returns the result of the `belongsToMany` method. The `belongsToMany` method is provided by the `Illuminate\Database\Eloquent\Model` base class that is used by all of your application's TinyORM models. For example, let's define a `roles` method on our `User` model. The first argument passed to this method is the name of the related model class:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class User extends Model
    {
        /**
         * The roles that belong to the user.
         */
        public function roles()
        {
            return $this->belongsToMany(Role::class);
        }
    }

Once the relationship is defined, you may access the user's roles using the `roles` dynamic relationship property:

    use App\Models\User;

    $user = User::find(1);

    foreach ($user->roles as $role) {
        //
    }

Since all relationships also serve as query builders, you may add further constraints to the relationship query by calling the `roles` method and continuing to chain conditions onto the query:

    $roles = User::find(1)->roles()->orderBy('name')->get();

To determine the table name of the relationship's intermediate table, TinyORM will join the two related model names in alphabetical order. However, you are free to override this convention. You may do so by passing a second argument to the `belongsToMany` method:

    return $this->belongsToMany(Role::class, 'role_user');

In addition to customizing the name of the intermediate table, you may also customize the column names of the keys on the table by passing additional arguments to the `belongsToMany` method. The third argument is the foreign key name of the model on which you are defining the relationship, while the fourth argument is the foreign key name of the model that you are joining to:

    return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');

<a name="many-to-many-defining-the-inverse-of-the-relationship"></a>
#### Defining The Inverse Of The Relationship

To define the "inverse" of a many-to-many relationship, you should define a method on the related model which also returns the result of the `belongsToMany` method. To complete our user / role example, let's define the `users` method on the `Role` model:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Role extends Model
    {
        /**
         * The users that belong to the role.
         */
        public function users()
        {
            return $this->belongsToMany(User::class);
        }
    }

As you can see, the relationship is defined exactly the same as its `User` model counterpart with the exception of referencing the `App\Models\User` model. Since we're reusing the `belongsToMany` method, all of the usual table and key customization options are available when defining the "inverse" of many-to-many relationships.

<a name="retrieving-intermediate-table-columns"></a>
### Retrieving Intermediate Table Columns

As you have already learned, working with many-to-many relations requires the presence of an intermediate table. TinyORM provides some very helpful ways of interacting with this table. For example, let's assume our `User` model has many `Role` models that it is related to. After accessing this relationship, we may access the intermediate table using the `pivot` attribute on the models:

    use App\Models\User;

    $user = User::find(1);

    foreach ($user->roles as $role) {
        echo $role->pivot->created_at;
    }

Notice that each `Role` model we retrieve is automatically assigned a `pivot` attribute. This attribute contains a model representing the intermediate table.

By default, only the model keys will be present on the `pivot` model. If your intermediate table contains extra attributes, you must specify them when defining the relationship:

    return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');

If you would like your intermediate table to have `created_at` and `updated_at` timestamps that are automatically maintained by TinyORM, call the `withTimestamps` method when defining the relationship:

    return $this->belongsToMany(Role::class)->withTimestamps();

> {note} Intermediate tables that utilize TinyORM's automatically maintained timestamps are required to have both `created_at` and `updated_at` timestamp columns.

<a name="customizing-the-pivot-attribute-name"></a>
#### Customizing The `pivot` Attribute Name

As noted previously, attributes from the intermediate table may be accessed on models via the `pivot` attribute. However, you are free to customize the name of this attribute to better reflect its purpose within your application.

For example, if your application contains users that may subscribe to podcasts, you likely have a many-to-many relationship between users and podcasts. If this is the case, you may wish to rename your intermediate table attribute to `subscription` instead of `pivot`. This can be done using the `as` method when defining the relationship:

    return $this->belongsToMany(Podcast::class)
                    ->as('subscription')
                    ->withTimestamps();

Once the custom intermediate table attribute has been specified, you may access the intermediate table data using the customized name:

    $users = User::with('podcasts')->get();

    foreach ($users->flatMap->podcasts as $podcast) {
        echo $podcast->subscription->created_at;
    }

<a name="filtering-queries-via-intermediate-table-columns"></a>
### Filtering Queries Via Intermediate Table Columns

You can also filter the results returned by `belongsToMany` relationship queries using the `wherePivot`, `wherePivotIn`, and `wherePivotNotIn` methods when defining the relationship:

    return $this->belongsToMany(Role::class)
                    ->wherePivot('approved', 1);

    return $this->belongsToMany(Role::class)
                    ->wherePivotIn('priority', [1, 2]);

    return $this->belongsToMany(Role::class)
                    ->wherePivotNotIn('priority', [1, 2]);

<a name="defining-custom-intermediate-table-models"></a>
### Defining Custom Intermediate Table Models

If you would like to define a custom model to represent the intermediate table of your many-to-many relationship, you may call the `using` method when defining the relationship. Custom pivot models give you the opportunity to define additional methods on the pivot model.

Custom many-to-many pivot models should extend the `Illuminate\Database\Eloquent\Relations\Pivot` class while custom polymorphic many-to-many pivot models should extend the `Illuminate\Database\Eloquent\Relations\MorphPivot` class. For example, we may define a `Role` model which uses a custom `RoleUser` pivot model:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Role extends Model
    {
        /**
         * The users that belong to the role.
         */
        public function users()
        {
            return $this->belongsToMany(User::class)->using(RoleUser::class);
        }
    }

When defining the `RoleUser` model, you should extend the `Illuminate\Database\Eloquent\Relations\Pivot` class:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Relations\Pivot;

    class RoleUser extends Pivot
    {
        //
    }

> {note} Pivot models may not use the `SoftDeletes` trait. If you need to soft delete pivot records consider converting your pivot model to an actual TinyORM model.

<a name="custom-pivot-models-and-incrementing-ids"></a>
#### Custom Pivot Models And Incrementing IDs

If you have defined a many-to-many relationship that uses a custom pivot model, and that pivot model has an auto-incrementing primary key, you should ensure your custom pivot model class defines an `incrementing` property that is set to `true`.

    /**
     * Indicates if the IDs are auto-incrementing.
     *
     * @var bool
     */
    public $incrementing = true;


EntityManager.hpp:
------------------

#ifndef ENTITYMANAGER_H
#define ENTITYMANAGER_H

#include "orm/databaseconnection.hpp"
#include "orm/repositoryfactory.hpp"

#ifdef TINYORM_COMMON_NAMESPACE
namespace TINYORM_COMMON_NAMESPACE
{
#endif
namespace Orm
{

    /*! The EntityManager is the central access point to ORM functionality. */
    class SHAREDLIB_EXPORT EntityManager final
    {
        Q_DISABLE_COPY(EntityManager)

    public:
        EntityManager(const QVariantHash &config);
        EntityManager(DatabaseConnection &connection);
        ~EntityManager();

        /*! Factory method to create EntityManager instances. */
        static EntityManager create(const QVariantHash &config);

        /*! Gets the repository for an entity class. */
        template<typename Repository>
        QSharedPointer<Repository> getRepository() const;

        /*! Create a new QSqlQuery. */
        QSqlQuery query() const;
        /*! Get a new query builder instance. */
        QSharedPointer<QueryBuilder> queryBuilder() const;
        /*! Check database connection and show warnings when the state changed. */
        bool pingDatabase();
        /*! Start a new database transaction. */
        bool transaction();
        /*! Commit the active database transaction. */
        bool commit();
        /*! Rollback the active database transaction. */
        bool rollback();
        /*! Start a new named transaction savepoint. */
        bool savepoint(const QString &id);
        /*! Rollback to a named transaction savepoint. */
        bool rollbackToSavepoint(const QString &id);

        /*! Get underlying database connection. */
        inline DatabaseConnection &connection() const
        { return m_db; }

    protected:
        /*! Factory method to create DatabaseConnection instances. */
        static DatabaseConnection &
        createConnection(const QVariantHash &config);

    private:
        /*! The database connection used by the EntityManager. */
        DatabaseConnection &m_db;
        /*! The repository factory used to create dynamic repositories. */
        RepositoryFactory m_repositoryFactory;
    };

    template<typename Repository>
    QSharedPointer<Repository> EntityManager::getRepository() const
    {
        return m_repositoryFactory.getRepository<Repository>();
    }

} // namespace Orm
#ifdef TINYORM_COMMON_NAMESPACE
} // namespace TINYORM_COMMON_NAMESPACE
#endif

#endif // ENTITYMANAGER_H


EntityManager.cpp:
------------------

#include "orm/entitymanager.hpp"

#include <QtSql/QSqlQuery>

#ifdef TINYORM_COMMON_NAMESPACE
namespace TINYORM_COMMON_NAMESPACE
{
#endif
namespace Orm
{

/*!
    \class EntityManager
    \brief The EntityManager class manages repositories and a connection
    to the database.

    \ingroup database
    \inmodule Export

    EntityManager is the base class to work with the database, it creates
    and manages repository classes by helping with the RepositoryFactory
    class.
    Creates the database connection which is represented by
    DatabaseConnection class.
    EntityManager should be used in controllers ( currently TorrentExporter
    is like a controller class ), services, and repository classes to access
    the database. There is no need to use the QSqlDatabase or the
    DatabaseConnection classes directly.
    EntityManager is also injected into a repository and a service
    classes constructors.
    The circular dependency problem is solved by including entitymanager.hpp
    in the baserepository.hpp file.
*/

EntityManager::EntityManager(const QVariantHash &config)
    : m_db(createConnection(config))
    , m_repositoryFactory(*this)
{}

EntityManager::EntityManager(DatabaseConnection &connection)
    : m_db(connection)
    , m_repositoryFactory(*this)
{}

EntityManager::~EntityManager()
{
    DatabaseConnection::freeInstance();
}

EntityManager EntityManager::create(const QVariantHash &config)
{
    return EntityManager(createConnection(config));
}

QSqlQuery EntityManager::query() const
{
    return m_db.query();
}

QSharedPointer<QueryBuilder> EntityManager::queryBuilder() const
{
    return m_db.query();
}

bool EntityManager::pingDatabase()
{
    return m_db.pingDatabase();
}

bool EntityManager::transaction()
{
    return m_db.transaction();
}

bool EntityManager::commit()
{
    return m_db.commit();
}

bool EntityManager::rollback()
{
    return m_db.rollback();
}

bool EntityManager::savepoint(const QString &id)
{
    return m_db.savepoint(id);
}

bool EntityManager::rollbackToSavepoint(const QString &id)
{
    return m_db.rollbackToSavepoint(id);
}

DatabaseConnection &
EntityManager::createConnection(const QVariantHash &config)
{
    return DatabaseConnection::create(config.find("database").value().toString(),
                                      config.find("prefix").value().toString(),
                                      config);
}

} // namespace Orm
#ifdef TINYORM_COMMON_NAMESPACE
} // namespace TINYORM_COMMON_NAMESPACE
#endif
